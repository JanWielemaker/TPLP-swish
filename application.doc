\section{The SWISH application}
\label{sec:application}

In the following sections we describe SWISH in terms of interface
components, where we discuss the requirements, the user aspects, the
client code and supporting server functionality	for each component.
First, we provide a screendump that illustrates the main components
in \figref{swish}.

\begin{figure}
    \includegraphics[width=\linewidth]{figs/swish-screendump}
    \caption{Screendump of SWISH. The left pane shows the source code,
	     while the top-right pane shows a query \jargon{runner} that
	     exploits the current selected answer \jargon{renderer} and
	     buttons on how to continue after the first answer. The
	     bottom-right pane provides the query editor with access to
	     example queries stored in the source, query history, apply
	     solution modifiers, result presentation and a \textsf{Run!}
	     button to start the query.}
    \label{fig:swish}
\end{figure}

\noindent
%================================================================
\subsection{The query editor}
\label{sec:queryeditor}

The \jargon{query editor} is based on the same jQuery plugin that
realises the code editor and thus profits from the syntax
highlighting, template insertion and hovering plugins.  In addition,
it provides three popup menus:

\begin{description}
    \item[Examples] This menu is filled from the structured comments
described above.  The examples menu is shown in \figref{lpn}.
    \item[History] This menu provides earlier executed queries.
    \item[Solutions]  This menu embeds an existing query in a meta-call to
alter the result. Currently provided operations are \textit{Aggregate
(count all)}, \textit{Order by}, \textit{Distinct}, \textit{Limit},
\textit{Time} and \textit{Debug (trace)}.  \Figref{aggregate} shows
how the menu is used to count the solutions of a goal.
\end{description}

\begin{figure}
    \includegraphics[width=\linewidth]{figs/aggregate}
    \caption{The \textsf{Solutions} menu can be used to count results,
	     order them, filter duplicates, etc. The upper runner shows
	     answers to the query as a table.}
    \label{fig:aggregate}
\end{figure}

\TODO{moved; needs to be re-integrated}
Prolog source files can embed \jargon{example queries} using structured
comments, where each sequence from \verb$?-$ to the matching full stop
token is added to the \textsf{Examples} menu of the query panel (see
\figref{lpn}). The comment below illustrates a call to append/3 embedded
in the source window.

\begin{code}
/** <examples>

?- append([one], [two,three], List).
*/
\end{code}

%================================================================
\subsection{Running a query: runners in the answer pane}
\label{sec:answerpane}

The answer pane is a placeholder for \jargon{runners}, where each runner
represents a query. The answer pane provides a menu for operations on
all runners inside it. Provided actions are \textsf{Collapse all},
\textsf{Expand all}, \textsf{Stop all} and \textsf{Clear}. Each runner
in the answer pane represents a query. The query may be completed,
running or waiting for user input. SWISH can manage multiple active
queries at the same time, up to an application defined maximum
(default~3).

Each runner provides its own set of commands to control the specific
query. During execution a runner provides an \textsf{Abort} button.
After query evaluation completes with an answer and more answers may be
available the runner allows for asking the next 1, 10, 100 or 1,000
results or to \textsf{Stop} the query. In addition, the runner shows a
\jargon{text input} field when the application wants to read input and
may show debugger interaction buttons if the tracer is being used (see
\secref{tracer}).

A runner can render answers in two modes, the classical Prolog mode or
as a table, similar to what many database interfaces provide. The
`table' mode is particularly appealing for querying datasets (see
\figref{aggregate}), while the former is more suitable for rendering
small amounts of complex answers such as the chessboard position in
\figref{swish}. By default, Prolog terms are rendered as structured HTML
objects, where rendered text is the same as Prolog's \index{writeq/1}\predref{writeq}{1} predicate.

The server can provide \jargon{rendering libraries} that render Prolog
terms using dedicated HTML. In \figref{swish}, the `chess' renderer is
loaded which translates a list of length $N$ holding integers in the
range $1..N$ as a chessboard with queens. In addition to the chess
rendering library, SWISH provides rendering libraries for sudoku
puzzles, parse trees and tables. The ClioPatria version adds a
renderer for RDF resources that renders the resource more compactly and
provides a hyperlink for obtaining details. If a term can be rendered in
multiple ways, the interface provides a hover menu to select between the
alternatives. \Figref{render} illustrates this functionality. The render
facility is similar to the Prolog \index{portray/1}\predref{portray}{1} hook that allows changing
the result printed for terms with a specific shape.  However, it can
exploit the full potential of HTML (or SVG) and the interface allow for
switching the selected rendering.

\begin{figure}
    \includegraphics[width=\linewidth]{figs/render}
    \caption{With the `chess' render library, a list of integers is
	     interpreted as queens on a chessboard.  The user can
	     select rendering as a `Prolog term' to see the actual
	     term.}
    \label{fig:render}
\end{figure}

If the SWISH user hits the \textsf{Run!} button, the content of the
source pane is used to create a new pengine. Subsequently, the content
of the query pane is sent as the one and only query that will be
executed by the pengine.\footnote{Pengines can execute multiple queries.
We do not use this facility because a fresh pengine starts in a
predictable state (standard operators, empty dynamic database).} Before
execution, the query is verified to be \emph{safe}, unless sandboxing is
disabled (see \secref{cliopatria}). The sandbox component is discussed
in \secref{sandbox}

The pengine's default working module may be pre-loaded with code. SWISH
uses this facility to redefine the Prolog I/O predicates such as \index{read/1}\predref{read}{1},
\index{write/1}\predref{write}{1}, \predref{format}{1,2,3}, etc. The ClioPatria version
(\secref{cliopatria}) also preloads the RDF libraries, so users can run
queries on the RDF database without explicitly importing the required
libraries.



%================================================================
\subsubsection{Debugging}
\label{sec:tracer}

The SWISH debugger is based on the traditional 4-port debugging model
for Prolog. \Figref{tracer} shows the tracer in action on \index{sublist/2}\predref{sublist}{2} from
the \textit{Lists} example source. The debugger was triggered by a
break-point on line~10 set by clicking on the line-number in the code
editor. The debugging interaction is deliberately kept simple and
similar to traditional programming environments. A \jargon{retry} button
is added to the commonly seen `step into', `step over' and `step out'
for highlighting the unique feature of Prolog to re-evaluate a goal.

\begin{figure}
    \includegraphics[width=\linewidth]{figs/swish-tracer}
    \caption{Debugging applications in SWISH}
    \label{fig:tracer}
\end{figure}


\section{The SWISH application}
\label{sec:application}

SWISH consists of two parts. The \emph{client side}, running in a
browser, is implemented as a series of jQuery plugins, using Bootstrap
for styling and RequireJS\footnote{\url{http://requirejs.org/}} for
package management. The \emph{server side} is completely implemented in
SWI-Prolog \cite{DBLP:journals/tplp/WielemakerHM08}. It builds on top of
the SWI-Prolog HTTP server libraries, the Pengines library and the IDE
support libraries that provide data for auto completion, documentation
and highlighting.

In the following sections we describe SWISH in terms of interface
components, where we discuss the requirements, the user aspects, the
client code and supporting server functionality	for each component.
First, we provide a screendump that illustrates the main components
in \figref{swish}.

\begin{figure}
    \includegraphics[width=\linewidth]{figs/swish-screendump}
    \caption{Screendump of SWISH. The left pane shows the source code,
	     while the top-right pane shows a query \jargon{runner} that
	     exploits the current selected answer \jargon{renderer} and
	     buttons on how to continue after the first answer. The
	     bottom-right pane provides the query editor with access to
	     example queries stored in the source, query history, apply
	     solution modifiers, result presentation and a \textsf{Run!}
	     button to start the query.}
    \label{fig:swish}
\end{figure}

%================================================================
\subsection{The code editor}

A proper editor is the most important component of a usable programming
environment. The editor must support the language, including syntax
highlighting, auto indentation, code completion based on templates and
already existing code and highlighting of errors and warning from the
compiler.  The editor is used both for editing the source code and
editing queries.

Prolog is a difficult language to support in code editors due to the
lack of reserved keywords, e.g., the word \const{if} in C starts an
if-statement if not embedded in comment or a string, but the word
\const{is} in Prolog can refer to the built-in predicate \index{is/2}\predref{is}{2}, but also
some predicate with a different arity, just a constant, etc. Another
example is \exam{X-Y} which can both be an arithmetic expression or a
\jargon{pair} as used with e.g., \index{keysort/2}\predref{keysort}{2}. Next to the lack of keywords
the ability to extend the syntax using new operators complicates the
implementation of syntax support while editing. SWI-Prolog's native
editor resolves this problem by closely integrating Prolog with the
editor. While typing, the current term (clause or directive) is parsed
and analysed in the context of the current file and the file's imports
after each keystroke. If the term has valid syntax, all tokens are
coloured according to their syntactic role as well their relation to the
remainder of the program. For example, a call to a non-existing
predicate is coloured red, a call to a built-in or imported predicate is
blue and a call to a locally defined predicate is black. The libraries
that implement this analysis have been decoupled from the native IDE,
both to support source colouring for the SWI-Prolog documentation system
PlDoc \cite{Wielemaker:2007c} and
ProDT\footnote{\url{http://prodevtools.sourceforge.net}, these libraries
are not yet used by ProDT.}

There are two dominant open source and actively maintained in-browser
code editors available: ACE and CodeMirror. When we started SWISH, ACE
had a very basic Prolog mode and CodeMirror had none. We nevertheless
opted for CodeMirror because its highlighting is based on raw JavaScript
code rather than a regular expression based template language as used
for ACE. The low level implementation allows for a novel highlighting
implementation. The highlighter consists of a JavaScript implemented
Prolog \emph{tokeniser}. Tokenizing Prolog is sufficient to colour
comments, quoted material (strings, quoted atoms), variables and
constants (atoms and numbers). It is also sufficient to support smart
indentation. As discussed above, it is not sufficient for highlighting
the role played by atoms and compound terms.\footnote{An additional
complication is formed by CodeMirror's token-based highlighting which
does not support look-ahead. As a consequence, we must decide on the
colour of e.g., \exam{asserta(} while we do not know the arity of the
term.}

We provide \jargon{semantic} highlighting by (1) forwarding the changes
to the content of the editor to the server server which maintains a
mirror of the editor content and (2) asking the server to produce a list
of semantically enriched tokens for the source. The tokens are returned
as a list-of-lists, where each inner list represents the tokens for a
source term (clause or directive). Grouping the tokens per source term
allows for incremental update (not implemented) as well as
re-synchronisation (see below). For example, a fragment of an enriched
token list may look like this: [ \textit{functor, (undefined_goal)},
\textit{variable (singleton)}, \ldots ]. The JavaScript tokeniser
matches its tokens with this list. If the basic type (e.g., `functor' or
`variable') matches, it uses the enrichment information (e.g.,
`singleton') to decide on the style. If the basic token type does not
match, it schedules a request to the server for a new version. This
request is sent if the user pauses typing for 2 seconds. The request is
accompanied by the full source if this is small or the list of changes
since the last request if the source is large. While waiting for
up-to-date enriched tokens, the JavaScript highlighting code
heuristically tries to re-synchronise and either uses the uncertain
results or falls back to the plain tokens. Re-synchronisation checks
whether a single added, deleted or modified token gets the token stream
in-sync. If this fails it tries to re-synchronise on a full-stop with
the next clause or directive.

A CodeMirror \jargon{hover} plugin is used to show basic information
about tokens if the pointer hovers over it. For goals, this includes
where the goal is defined (ISO, SWI-Prolog built-in, a library, locally)
and the documentation summary information if available. This information
is requested from the server.

A CodeMirror \jargon{template} plugin is configured from templates
(e.g., \exam{atom_length(+Atom, -Length)}) extracted from the SWI-Prolog
manual and PlDoc documentation of imported libraries. This plugin shows
a menu of applicable predicates with their templates on
\textsf{Control-Space}.

Finally, if the compiler generates errors or warnings, these are
inserted as notes in the source code.

%================================================================
\subsection{Source code and query management}
\label{sec:gitty}

As JSFiddle formed the initial inspiration for SWISH, SWISH has a
facility to save the program. The current version of SWISH explicitly
targets the cooperative development of Prolog programs and queries
related to a dataset (see \secref{cliopatria}). This triggered the
implementation of a more organised storage facility. The server-side
storage module is implemented in Prolog and inspired by GIT. Each file
is versioned independently rather than maintaining the version of a
hierarchy of files. Files can be referenced by content using their GIT
compatible SHA1 hash or by name. The name can be considered a
version \jargon{head} and refers to the latest version with that name.
The file save and load interface provides the following operations:

\begin{itemize}
    \item Saving a file anonymously, which produces a randomly
          generated URL similar to JSFiddle.
    \item Saving a file by name.
    \item Saving a new version.  The interface shows the available
          versions and the modifications.
    \item Forking a file under a new name.  The history remains
          linked to the original.
\end{itemize}

Prolog source files can \jargon{include} other sources on the same
server using \exam{:-~include(filename).}, including the latest
version or \exam{:-~include(hash).} to include a specific version.

Prolog source files can embed \jargon{example queries} using structured
comments, where each sequence from \verb$?-$ to the matching full stop
token is added to the \textsf{Examples} menu of the query panel (see
\figref{lpn}). The comment below illustrates a call to \index{append/3}\predref{append}{3} embedded
in the source window.

\begin{code}
/** <examples>

?- append([one], [two,three], List).
*/
\end{code}

\noindent
%================================================================
\subsection{The query editor}
\label{sec:queryeditor}

The \jargon{query editor} is based on the same jQuery plugin that
realises the code editor and thus profits from the syntax
highlighting, template insertion and hovering plugins.  In addition,
it provides three popup menus:

\begin{description}
    \item[Examples] This menu is filled from the structured comments
described above.  The examples menu is shown in \figref{lpn}.
    \item[History] This menu provides earlier executed queries.
    \item[Solutions]  This menu embeds an existing query in a meta-call to
alter the result. Currently provided operations are \textit{Aggregate
(count all)}, \textit{Order by}, \textit{Distinct}, \textit{Limit},
\textit{Time} and \textit{Debug (trace)}.  \Figref{aggregate} shows
how the menu is used to count the solutions of a goal.
\end{description}

\begin{figure}
    \includegraphics[width=\linewidth]{figs/aggregate}
    \caption{The \textsf{Solutions} menu can be used to count results,
	     order them, filter duplicates, etc. The upper runner shows
	     answers to the query as a table.}
    \label{fig:aggregate}
\end{figure}

%================================================================
\subsection{Running a query: runners in the answer pane}
\label{sec:answerpane}

The answer pane is a placeholder for \jargon{runners}, where each runner
represents a query. The answer pane provides a menu for operations on
all runners inside it. Provided actions are \textsf{Collapse all},
\textsf{Expand all}, \textsf{Stop all} and \textsf{Clear}. Each runner
in the answer pane represents a query. The query may be completed,
running or waiting for user input. SWISH can manage multiple active
queries at the same time, up to an application defined maximum
(default~3).

Each runner provides its own set of commands to control the specific
query. During execution a runner provides an \textsf{Abort} button.
After query evaluation completes with an answer and more answers may be
available the runner allows for asking the next 1, 10, 100 or 1,000
results or to \textsf{Stop} the query. In addition, the runner shows a
\jargon{text input} field when the application wants to read input and
may show debugger interaction buttons if the tracer is being used (see
\secref{tracer}).

A runner can render answers in two modes, the classical Prolog mode or
as a table, similar to what many database interfaces provide. The
`table' mode is particularly appealing for querying datasets (see
\figref{aggregate}), while the former is more suitable for rendering
small amounts of complex answers such as the chessboard position in
\figref{swish}. By default, Prolog terms are rendered as structured HTML
objects, where rendered text is the same as Prolog's \index{writeq/1}\predref{writeq}{1} predicate.

The server can provide \jargon{rendering libraries} that render Prolog
terms using dedicated HTML. In \figref{swish}, the `chess' renderer is
loaded which translates a list of length $N$ holding integers in the
range $1..N$ as a chessboard with queens. In addition to the chess
rendering library, SWISH provides rendering libraries for sudoku
puzzles, parse trees and tables. The ClioPatria version adds a
renderer for RDF resources that renders the resource more compactly and
provides a hyperlink for obtaining details. If a term can be rendered in
multiple ways, the interface provides a hover menu to select between the
alternatives. \Figref{render} illustrates this functionality. The render
facility is similar to the Prolog \index{portray/1}\predref{portray}{1} hook that allows changing
the result printed for terms with a specific shape.  However, it can
exploit the full potential of HTML (or SVG) and the interface allow for
switching the selected rendering.

\begin{figure}
    \includegraphics[width=\linewidth]{figs/render}
    \caption{With the `chess' render library, a list of integers is
	     interpreted as queens on a chessboard.  The user can
	     select rendering as a `Prolog term' to see the actual
	     term.}
    \label{fig:render}
\end{figure}

%================================================================
\subsubsection{Server side execution of the query}
\label{sec:pengines}

Server-side execution of a query is supported by the Pengines
\cite{DBLP:journals/tplp/LagerW14} library. The Pengines library allows
for creating a Prolog engine represented by a Prolog thread. Optionally,
the pengine is handed a Prolog program that is loaded into the pengine's
workspace (program space). The workspace is a temporary module that is
disposed of after the pengine terminates. The pengine may be asked
questions through HTTP queries, similar to a traditional Prolog user
interacting with Prolog running in a
terminal.\footnote{\url{https://www.youtube.com/watch?v=G_eYTctGZw8}}

If the SWISH user hits the \textsf{Run!} button, the content of the
source pane is used to create a new pengine. Subsequently, the content
of the query pane is sent as the one and only query that will be
executed by the pengine.\footnote{Pengines can execute multiple queries.
We do not use this facility because a fresh pengine starts in a
predictable state (standard operators, empty dynamic database).} Before
execution, the query is verified to be \emph{safe}, unless sandboxing is
disabled (see \secref{cliopatria}). The sandbox component is discussed
in \secref{sandbox}

The pengine's default working module may be pre-loaded with code. SWISH
uses this facility to redefine the Prolog I/O predicates such as \index{read/1}\predref{read}{1},
\index{write/1}\predref{write}{1}, \predref{format}{1,2,3}, etc. The ClioPatria version
(\secref{cliopatria}) also preloads the RDF libraries, so users can run
queries on the RDF database without explicitly importing the required
libraries.


%================================================================
\subsubsection{Sandboxing queries}
\label{sec:sandbox}

Prolog systems provide a programming environment that is capable of
changing itself permanently and which exposes a rich and potentially
dangerous interface to the operating system. Both for education purposes
and data analysis though, one can write meaningful programs without
making permanent changes to the server or the server's filesystem. That
is where the sandbox library comes in. The sandbox library is active
while loading the source, where it refuses to add clauses to other
modules than the pengine's workspace and where it only accepts a
restricted set of \jargon{directives}, also aimed at keeping all changes
local to the workspace. Prior to execution, the sandbox unfolds the
query and compares all reachable goals with a whitelist.  It fails
under one of these conditions:

\begin{itemize}
    \item It discovers a (meta-) goal for which it cannot deduce the
    called code.  The traditional example is \exam{read(X), call(X)}.
    If such a goal is encountered, it signals an \jargon{instantiation
    error}, together with a trace that explains how the insufficiently
    instantiated goal can be reached. Note that it can deal with normal
    high-order predicates if the meta-argument is specified. For
    example, the following goal is accepted as safe.

    \begin{code}
    ?- maplist(plus(1), [1,2,3])
    \end{code}

\noindent
    \item It discovers a goal that is not whitelisted.  In this case
    it signals a \jargon{permission error}, again accompanied with
    a trace that explains how the goal can be reached.  Note that
    pure Prolog predicates are unfolded, also if it concerns predicates
    from the libraries or belonging to the set of built in predicates.

    \item It discovers a cross-module (\arg{M:Goal}) call to a predicate
    that is not public. Normally, SWI-Prolog, in the tradition of
    Quintus Prolog, allows for this. Allowing it in SWISH would imply
    that no data can be kept secret. With this limitation, libraries can
    keep data in local dynamic predicates that remain invisible to
    non-authorised users.
\end{itemize}

%================================================================
\subsubsection{Debugging}
\label{sec:tracer}

The SWISH debugger is based on the traditional 4-port debugging model
for Prolog. \Figref{tracer} shows the tracer in action on \index{sublist/2}\predref{sublist}{2} from
the \textit{Lists} example source. The debugger was triggered by a
break-point on line~10 set by clicking on the line-number in the code
editor. The debugging interaction is deliberately kept simple and
similar to traditional programming environments. A \jargon{retry} button
is added to the commonly seen `step into', `step over' and `step out'
for highlighting the unique feature of Prolog to re-evaluate a goal.

\begin{figure}
    \includegraphics[width=\linewidth]{figs/swish-tracer}
    \caption{Debugging applications in SWISH}
    \label{fig:tracer}
\end{figure}


%================================================================
\section{Portability}
\label{sec:portability}

The SWISH client libraries are based on mature and well maintained
JavaScript libraries. The client runs all modern major browsers with
HTML5, CSS and JavaScript support. It is frequently tested on FireFox,
Chrome, Safari and Internet Explorer~11.

The server code is basically non-portable. Many of the required
libraries and features are shared with at least one other Prolog
implementation, but none is capable to support the full range. Below we
summarise the main problems.

\begin{itemize}
    \item The scale of the involved Prolog libraries demands for
    a closely compatible Prolog module system.  Probably only
    SICStus and YAP can be used without significant rewrites.

    \item The HTTP server libraries are heavily based on C~code
    that interacts with the SWI-Prolog foreign language interface
    to Prolog streams.  YAP has copied the low-level libraries and is
    capable to run (an old version of) these libraries.

    \item The Pengines library depends on the HTTP library and
    the multi-thread interface.  The SWI-Prolog thread API is
    also provided by YAP and XSB.

    \item The sandbox library (\secref{sandbox}) assumes that
    whitelisted predicates are indeed safe.  This requires robust
    handling of invalid calls and resource overflows.  Few Prolog
    systems can satisfy this requirement.  SICStus Prolog would
    be a candidate, but SICStus does not support multi-threading.

    \item The semantic syntax highlighting depends on detailed
    source layout information provided by \index{read_term/3}\predref{read_term}{3}.  SWI-Prolog's
    support for term layout is an extended version of the Quintus
    Prolog term layout functionality.

    \item Significant parts of the code rely on SWI-Prolog version~7
    extensions, notably the \jargon{dict} and \jargon{string} types
    that facilitate a natural mapping between Prolog and JSON data.
\end{itemize}

From the above list it should be clear that a fully functional port of
SWISH to another Prolog system is not immediately feasible. YAP probably
comes closest but still requires a significant amount of work.

There is a more realistic scenario though. In this setup, SWI-Prolog
provides the web interface and most of the development tools and another
language, not even necessarily Prolog, provides the query solving. The
interface between the two can be based on interprocess communication or,
especially if the target system is safe and capable of supporting
threads, by linkin the target system into the process and using the
C~interface.
